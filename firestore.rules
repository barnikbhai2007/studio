rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * FootyDuel Security Rules
     *
     * Core Philosophy: 
     * This ruleset enforces a hybrid security model: strict user-ownership for personal profiles and a 
     * participant-based collaborative model for game sessions. Access to static game content (footballers, 
     * hints, emotes) is public to all authenticated users.
     *
     * Data Structure:
     * - /userProfiles/{userId}: Private user data.
     * - /footballers/{footballerId}: Global static footballer data.
     * - /gameRooms/{gameRoomId}: Shared 1v1 match data.
     * - /emotes/{emoteId}: Global static emote data.
     *
     * Key Security Decisions:
     * - Prototyping Mode: Schema types are not enforced to allow rapid iteration, but relational 
     *   integrity (e.g., owner IDs matching auth UIDs) is strictly required for writes.
     * - Denormalization: GameRoom participant IDs (player1Id, player2Id) are denormalized into 
     *   GameRound documents to ensure authorization decisions are performant and independent.
     * - Structural Segregation: Read-only game assets are separated from mutable game state and user data.
     */

    // --- Global Helper Functions ---

    /** Checks if the request is from an authenticated user. */
    function isSignedIn() {
      return request.auth != null;
    }

    /** Checks if the authenticated user's UID matches the provided userId. */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /** Checks ownership and ensures the document exists before allowing modifications. */
    function isExistingOwner(userId) {
      return resource != null && isOwner(userId);
    }

    /** Checks if the authenticated user is one of the two participants in a game document. */
    function isParticipant(data) {
      return isSignedIn() && (data.player1Id == request.auth.uid || data.player2Id == request.auth.uid);
    }

    // --- Collection Rules ---

    /**
     * @description Rules for user profiles. Only the owner can create, read, or update their own profile.
     * @path /userProfiles/{userId}
     * @allow (get, list, create, update) if UID matches userId in path.
     * @deny (create) if auth.uid != userId.
     * @principle Enforces strict private data ownership using path-based authorization.
     */
    match /userProfiles/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for footballers. Static data is publicly readable but restricted from client writes.
     * @path /footballers/{footballerId}
     * @allow (get, list) for any user.
     * @deny (create, update, delete) for all client-side requests.
     * @principle Implements structural segregation for public read-only assets.
     */
    match /footballers/{footballerId} {
      allow get, list: if true;
      allow create, update, delete: if false;

      /**
       * @description Rules for footballer hints. Inherits the public read-only posture of the parent.
       * @path /footballers/{footballerId}/hints/{hintId}
       * @allow (get, list) for any user.
       * @deny (create, update, delete) for all client-side requests.
       * @principle Continues hierarchy for nested read-only data.
       */
      match /hints/{hintId} {
        allow get, list: if true;
        allow create, update, delete: if false;
      }
    }

    /**
     * @description Rules for game rooms. Creator must be player1; only participants can read or update state.
     * @path /gameRooms/{gameRoomId}
     * @allow (get) if user is player1 or player2. (list) if user is signed in.
     * @deny (update) if user is not a participant.
     * @principle Uses shared access (Closed Collaborators) based on member UIDs.
     */
    match /gameRooms/{gameRoomId} {
      allow get: if isSignedIn() && isParticipant(resource.data);
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.player1Id == request.auth.uid;
      allow update: if isSignedIn() && isParticipant(resource.data) && request.resource.data.player1Id == resource.data.player1Id;
      allow delete: if isSignedIn() && isParticipant(resource.data);

      /**
       * @description Rules for game rounds. Uses denormalized IDs for independent participant authorization.
       * @path /gameRooms/{gameRoomId}/gameRounds/{roundId}
       * @allow (create, get, update) if user is a participant.
       * @deny (update) if player IDs are tampered with.
       * @principle Employs denormalization for performant authorization without parent get() calls.
       */
      match /gameRounds/{roundId} {
        allow get: if isSignedIn() && isParticipant(resource.data);
        allow list: if isSignedIn();
        allow create: if isSignedIn() && isParticipant(request.resource.data);
        allow update: if isSignedIn() && isParticipant(resource.data) && request.resource.data.player1Id == resource.data.player1Id;
        allow delete: if isSignedIn() && isParticipant(resource.data);
      }
    }

    /**
     * @description Rules for emotes. Static data is publicly readable but restricted from client writes.
     * @path /emotes/{emoteId}
     * @allow (get, list) for any user.
     * @deny (create, update, delete) for all client-side requests.
     * @principle Implements structural segregation for public read-only assets.
     */
    match /emotes/{emoteId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }
  }
}